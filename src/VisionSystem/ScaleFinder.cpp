/*
 * ScaleFinder.cpp
 *
 *  Created on: Feb 14, 2018
 *      Author: wentzdr
 */

/* Algorithm to find a line from a series of points
 *
 * Used for detecting scale edge
 * Accepts an array of up to 25 points - this is generated by the image processor
 * Finds any line between two of those points that is close to horizontal and has many points on it
 *
 * Algorithm:
 * 1) Draw a line from each point to each other point and find slope and offset of the line
 * 2) Discard lines that are too steep to be the scale edge
 * 3) Check how far each other point is from the computed line
 * 4) If enough points are on the line, record it as a possible scale
 * 5) After checking all possible lines, return the line with the most points
 */

#include "ScaleFinder.h"

ScaleFinder::ScaleFinder() {
	maxDistanceFromLine = 5;
	maxSlope = 2;
	minSlope = -2;
	numReqPoints = 6;
	maxAvgSeparation = 25;

	verbose = false;
}

ScaleFinder::~ScaleFinder() {
	// TODO Auto-generated destructor stub
}

//Function to find the edge of a scale. Returns the a ScaleLine object representing the edge of the scale.
ScaleLine ScaleFinder::findScale(int points[maxNumPoints][2]){

	ScaleLine line = ScaleLine();
	int linePoints[maxNumPoints][2] = { };
	int numPointsBestLine = 0;


	//cycle through up to maxNumPoints points in the image
	//point number is limited to control processing time
	for(int i = 0; i < maxNumPoints; ++i){
		for(int j = i + 1; j < maxNumPoints; ++j) {

			//Skip array points that were not initialized (value is 0). This is true when there are less than 25 total points in the image
			if(points[i][0] <= 0 || points[i][1] <= 0 || points[j][0] <= 0 || points[j][1] <= 0) {
				if(verbose) std::cout<<"Skipping rest of point "<< i<<"\n";
				break;
			}

			if(verbose) std::cout<<"Points: "<<points[i][0]<<", "<<points[i][1]<<" and "<<points[j][0]<<", "<<points[j][1]<<"... ";

			//********************STEP 1 - calculate line**************************
			//Calculate the slope and offset of the line from point i to point j
			double xDelta = points[i][0] - points[j][0];
			double yDelta = points[i][1] - points[j][1];
			//Protect against division by 0
			if( xDelta == 0) break;

			double slope = ( yDelta / xDelta );
			int offset = (points[i][1]) - (slope * static_cast<double>(points[i][0]));

			if(verbose) std::cout<<"Slope: "<<slope<<" Offset: "<<offset<<" ";

			//*****************STEP 2 - rule out implausible lines**********************************
			//skip remaining processing for any line with a slope that could not plausibly be the scale
			if(slope > maxSlope || slope < minSlope) {
				if(verbose) std::cout<<"Slope out of range \n";
				break;
			}

			//******************STEP 3 - check if points are on line*************************
			//Determine if the other points are on this line
			bool isPointOnLine[maxNumPoints] = {};
			int numPointsOnLine = 0;
			for(int k = 0; k < maxNumPoints; ++k)
			{
				//Calculate the dependent (Y) coordinate for each of the detected independent (x) points that the robot sees
				//if those points were all on the line formed by the two points being tested
				double y = slope * points[k][0] + offset;

				//Determine if the point k is on the line from point i to point j, skipping uninitialized points
				if(std::abs (y - points[k][1] ) < maxDistanceFromLine && points[k][0] > 0 && points[k][1] > 0) {
					isPointOnLine[k] = true;
					linePoints[numPointsOnLine][0] = points[k][0];
					linePoints[numPointsOnLine][1] = points[k][1];
					numPointsOnLine++;
				} else {isPointOnLine[k] = false;}
			}

			//Calculate the average distance between consecutive points on the line
			double avgPointSeparation = 0;
			for(int k = 0; k < numPointsOnLine - 1; ++k)	{
				avgPointSeparation += linePoints[k][0] - linePoints[k + 1][0];
			}
			if(numPointsOnLine > 0) avgPointSeparation = avgPointSeparation / numPointsOnLine;
			else avgPointSeparation = 0;
			if(verbose) std::cout<<"LinePoints: "<<numPointsOnLine<<" Avg Separation: "<<avgPointSeparation<<"\n";

			//*****************STEP 4 - determine if this line is the scale edge*****************************
			if(numPointsOnLine >= numReqPoints  && numPointsOnLine > numPointsBestLine && std::abs(avgPointSeparation) < maxAvgSeparation){

				//Set the current line as the best one so far and print out it's data
				numPointsBestLine = numPointsOnLine;
				for(int m = 0; m < numPointsOnLine; ++m) {
				 if(verbose) std::cout<<linePoints[m][0]<<", "<<linePoints[m][1]<<"\n";
				}
				std::cout<<"\n";

				//Copy line parameters into return object
				for(int n = 0; n < numPointsOnLine; n++){
					line.linePoints[n][0] = linePoints[n][0];
					line.linePoints[n][1] = linePoints[n][1];
				}

				line.startX = linePoints[0][0];
				line.startY = linePoints[0][1];
				line.endX = linePoints[numPointsOnLine - 1][0];
				line.endY = linePoints[numPointsOnLine - 1][1];
				line.numPoints = numPointsOnLine;
				line.slope = slope;
				line.offset = offset;
				line.detected = true;
				line.midX = (line.startX + line.endX) / 2;
				line.midY = (line.startY + line.endY) / 2;
			}
		}
	}
	//after processing all points, return the best line that was found
	//line object will be empty if no line was found

	if(line.detected){
		std::cout<<"\n*****SCALE FOUND*****\nPoints: "<<line.numPoints<<" *** ";
		std::cout<<"Slope: "<<line.slope<<"\n"<<"Start: "<<line.startX<<", "<<line.startY<<" *** End: "<<line.endX<<", "<<line.endY<<" *** Mid: "<<line.midX<<", "<<line.midY<<"\n";
	} else std::cout<<"No scale found :(\n";

	return line;
}

void ScaleFinder::updateCals()
{
	//Put code here to update cals from smartdashboard

	//pointsOnLine
	//maxDistanceFromLine
	//maxSlope
	//minSLope
	//numReqPoints
	//maxAvgSeparation
}
